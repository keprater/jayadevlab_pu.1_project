---
title: "snRNAseq_Density_Umap_plot_v1"
author: "Katie Prater and Kevin Green"
date: "07/14/2021"
output:
  html_document:
    df_print: paged
params:
  container: ""
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(reticulate)
use_condaenv("/gscratch/jayadevlab/software/conda/envs/miniconda_setup", 
             required = TRUE)
library(Seurat)
library(ggplot2)
library(Matrix)
library(filesstrings)
library(rlist)
library(loomR)
#library(SeuratDisk)
```
# Jayadev Lab snRNAseq Pipeline

## Uses Scanpy command to generate a density umap plot to demonstrate cluster enrichment differences between sample populations

### R Markdown note:
This is an R Markdown document. When you click the **Knit** button a document
will be generated that includes both content as well as the output of any
embedded R code chunks within the document.

## Set the dataset that needs to have doublets detected.
# You MUST edit this for your dataset to run properly!!!!
```{r Directory_setup}
# Name of the Rdata file to load in:
start_data <- "QCd_leiden_clustered_ws_20pcs_no-ref_APOE33.rdata"

# Variable to split the dataset by:
split_var <- "Study_Designation"

# Set the resolution of clustering that you want to use
change_resolution <- "0.3"

# Set the cluster(s) you want to plot
include_clusters <- c("3", "8")

# ***Note HARDCODING for PU.1 dataset is present in this script! ****

#__________________Do not edit below this line______________________________
```

### Load in the data you specified:
```{r Load_Data}
# Document your code:
print(paste("This is when this code was started:", Sys.time()))

# Print which container is being used
if (identical(params$container, "")) {
  stop("The container number must be documented before rendering.
       params= list(container = ###)")
}
print(paste("Container number", params$container, "was used"))

# Load the thresholded Seurat object saved before
print(paste('Loading data', start_data, sep = " "))
load(paste0("../data/r_files/", start_data))

# Print container package versions, if changed from previous
if (!identical(params$container, prev_container)) {
  print("This code was run using:")
  print(sessionInfo())
  prev_container <- params$container
}
rm(params)
Sys.umask(mode = "007")

# Ensure resolution to be used is set properly.
if (!is.null(change_resolution)) {
  chose_resolution <- change_resolution
  #make resolution name:
  res_name<- paste0(assay, "_snn_res.", chose_resolution)

  #Set cluster identities in Seurat object
  Idents(object = ss_data_norm)<-res_name
}
```

```{r Set_Directories}
# Number of participants/samples to process:
numsubs <- length(samples)
print(paste("Processing", numsubs, "samples", sep = " "))

# Documentation:
print(paste("This is where the project is:", normalizePath(projdir)))
print(paste("This is where the sample files are:", normalizePath(sample_dir)))
print(paste("This is where the data files will be saved:",
             normalizePath(umaps_path)))
```

### If the groups don't match in size, downsample the larger group in order to scale the data appropriately for the visualization
```{r Downsample_Subset_Seurat}

# Check if the number of nuclei in the groups is different. If so, downsample
# the larger group.
# **** Not currently flexible *****
#ss_data_norm <- subset(x = ss_data_norm, downsample = 50787)

# Generate a table with the # nuclei per group after downsampling
# overall <- table(Idents(ss_data_norm))
# print(paste("The number of nuclei in each group after downsampling is:"))
# overall

# Ensure the assay is set to integrated so that you pull the appropriate data
if (identical(assay, "integrated")){
  DefaultAssay(ss_data_norm) <- assay
} else {
  DefaultAssay(ss_data_norm) <- "integrated"
}

# Check if the user asked for the dataset to be subset and do the subset
if (is.character(include_clusters)) {
  print("Subsetting seurat object by including clusters:")
  print(include_clusters)

  # Subset the seurat object
  ss_data_norm <- subset(ss_data_norm, idents = include_clusters)

} else {
  print("Using whole dataset")
}

# Set the Idents of the Seurat Object to match your split variable of interest
Idents(ss_data_norm) <- split_var

# Generate a table with the # nuclei per group before downsampling
overall <- table(Idents(ss_data_norm))
print(paste("The number of nuclei in each group is:"))
overall

```

### Convert the Seurat object to anndata so that we can use the scanpy functions
```{r convert_data}
# Check if the loom file exists. If it does not, generate it.
if (file.exists("../data/r_files/ss_data_norm.loom")) {
  print("The loom file already exists! Moving on.")
} else {
  # Force metadata to characters and NA to "N.A" for conversion to loom
  for(j in 1:ncol(ss_data_norm@meta.data)){
    if(is.factor(ss_data_norm@meta.data[,j]) == T){
      ss_data_norm@meta.data[,j] = as.character(ss_data_norm@meta.data[,j]) # Force the variable type to be character
      ss_data_norm@meta.data[,j][is.na(ss_data_norm@meta.data[,j])] <- "N.A"
    }
    if(is.character(ss_data_norm@meta.data[,j]) == T){
      ss_data_norm@meta.data[,j][is.na(ss_data_norm@meta.data[,j])] <- "N.A"
    }
  }
  
  # Convert our Seurat object to a loom data file HDF5 file type that scanpy can read
  loom.ss_data_norm <- as.loom(ss_data_norm, filename = "../data/r_files/ss_data_norm.loom", verbose = FALSE)
  
  loom.ss_data_norm
  loom.ss_data_norm$close_all()
}

```

### Use Scanpy to make the plot:
### Scanpy is a python package, so we are using a python code chunk here for a bit.
```{python Scanpy_Enrichment_Plot}
# Document which version of Python you are using
import sys
print("You are using Python {}.{}.".format(sys.version_info.major,
      sys.version_info.minor))

# Setup Python with the libraries we want to use
import scanpy as sc
import loompy
import scipy.io
import matplotlib.pyplot as plt
from matplotlib import rcParams
from matplotlib import colors
import matplotlib
matplotlib.use('AGG')
import numpy as np

# Read in the Seurat object to python
# input_dir = r.projdir
dataset = sc.read_loom("../data/r_files/ss_data_norm.loom", sparse = True, cleanup = False)

# Provide the split_var to python
sp_var = r.split_var
clusters = r.include_clusters

# Provide the anndata object the Seurat umap embeddings
dataset.obsm['X_umap'] = dataset.obsm['umap_cell_embeddings']

# Visualize the data using the scanpy density function
sc.tl.embedding_density(dataset, basis='umap', groupby= sp_var)

dataset.obs[sp_var].value_counts()


# fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(8,6), gridspec_kw={'wspace':0.9})

sc.pl.embedding_density(dataset, basis='umap', groupby= sp_var)

# def cluster_small_multiples(adata, clust_key, size=60, frameon=False, legend_loc=None, **kwargs):
#     tmp = adata.copy()
# 
#     for i,clust in enumerate(adata.obs[clust_key].cat.categories):
#         tmp.obs[clust] = adata.obs[clust_key].isin([clust]).astype('category')
#         tmp.uns[clust+'_colors'] = ['#d3d3d3', adata.uns[clust_key+'_colors'][i]]
# 
#     sc.pl.umap(tmp, groups=tmp.obs[clust].cat.categories[1:].values, color=adata.obs[clust_key].cat.categories.tolist(), size=size, frameon=frameon, legend_loc=legend_loc, **kwargs)
# 
# cluster_small_multiples(dataset, 'clusters')

#sc.pl.embedding_density(dataset, basis='umap', groupby= sp_var, group=[[c] for c in dataset.obs[clusters].cat.categories])
# sc.pl.embedding_density(dataset, basis='umap', groupby= sp_var, group='AD')

# plt.show()
# plt.savefig(sp_var + '_nuclei_enrichment_density.png', transparent=True)


```

### Plot was generated, now we put the data in the output
### folder.
```{r Cleanup_Files}
# Move the histograms and umap images to the output folder.
#pngs<- Sys.glob("*.png")
#move_files(pngs, umaps_path, overwrite = FALSE)

#print(paste('Scrublet data and plots stored in:', umaps_path, sep = ' '))
```
