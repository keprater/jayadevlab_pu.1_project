---
title: "18_muscat_pseudobulk_DS_v1"
author: "Katie Prater and Kevin Green"
date: "8/14/2020"
output: 
  html_document:
    df_print: paged
params:
  container: ""
---

```{r setup, cache=FALSE, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(Seurat)
library(Matrix)
library(scater)
library(cowplot)
library(Matrix.utils)
library(edgeR)
library(magrittr)
library(reshape2)
library(S4Vectors)
library(SingleCellExperiment)
library(pheatmap)
library(apeglm)
library(png)
library(DESeq2)
library(RColorBrewer)
library(data.table)
library(patchwork)
library(clusterProfiler)
library(muscat)
library(ggrepel)
```

# Jayadev Lab snRNAseq Pipeline

## Detection of Differential genes by pseudobulk analysis

### R Markdown note:
This is an R Markdown document. When you click the **Knit** button a document
will be generated that includes both content as well as the output of any
embedded R code chunks within the document.

## Set the dataset with cluster identities.
# You MUST edit this for your dataset to run properly!!!!
```{r Setup}
# Previous data file name: (give the name for the appopriate RDS/Rdata file)
start_data <- "QCd_leiden_clustered_ws_20pcs_mg_only_mnn_20210331.rdata"

# Change output path if necessary, otherwise leave NULL
change_output_path <- NULL

# Set the sample ID meta-data variable name
ID <- "Pt_ID"

# Set variables from metadata on which to perform DEG (must match variable names
# in metadata exactly). All other variables given will be regressed out before
# testing each variable. For this reason, use caution when adding many when the
# sample size is small.
meta_vars <- c("Study_Designation", "Sex")

# Set the reference value of the each meta_var (e.g. "Ctrl")
ref <- c("Ctrl", "M")

# Set cluster names that need to be removed from analysis
remove <- NULL
  
# Input any metadata variables for discrete groups that are set as integers
# (e.g. mutation status = 0 or 1). Otherwise, NULL
meta_factors <- NULL

# Choose the minimum fold change of a gene, in either group being tested, for
# the gene to be tested. Fold change is expressed as log base 2.
# (0.585 ~ 1.5 increase, 0.322 ~ 1.25 increase)
log2_threshold <- 0.585

# Input which colors to use in the plots. Input as a list
# (e.g. c("gray", "salmon")) or a color palette (e.g. brewer.pal(3, "Paired"))
colors <- c("gray", "salmon")

# Which method for GSEA do you wish to use? Use "wald" for the Wald statistic,
# "lfc" for the shrunken log2 fold change, "-log10p" for the
# -log10(p-value), or NULL to perform no GSEA.
method <- "wald"

# Resolution chosen from previous clustering to use to label clusters:
change_resolution <- "0.3"

# Set which clusters should be combined. If no clusters are to be combined, set
# to NULL. 
# IF NOT NULL, THIS WILL RUN ONLY THE COMBINED CLUSTERS
combined <- NULL
#__________________**DO NOT EDIT BELOW THIS LINE**___________________________
```

## Load in the data you specified:
```{r Load_Data}
# Document your code:
print(paste("This is when this code was started:", Sys.time()))

# Print which container is being used
if (identical(params$container, "")) {
  stop("The container number must be documented before rendering.
       params= list(container = ###)")
}
print(paste("Container number", params$container, "was used"))

# Load the normalized/batch corrected Seurat object saved before
print(paste('Loading data', start_data, sep = " "))
load(paste0("../data/r_files/", start_data))

# Print container package versions, if changed from previous
if (!identical(params$container, prev_container)) {
  print("This code was run using:")
  print(sessionInfo())
  prev_container <- params$container
}
rm(params)

# Change permissions to open for files created
Sys.umask("000")

# Change output path if a new one is provided.
if (!is.null(change_output_path)) {
  print("Changing output path")
  outpath <- change_output_path
}

# Ensure resolution to be used is set properly.
if (!is.null(change_resolution)) {
  chose_resolution <- change_resolution
  
  # First ensure that the idents are set to the resolution of clusters that you
  # want. Remake resolution name to ensure it's accurate:
  res_name <- paste0(assay, "_snn_res.", chose_resolution)
  
  Idents(object = ss_data_norm) <- res_name
}

# Change the active assay to the assay to be evaluated for DEG
DefaultAssay(ss_data_norm) <- "RNA"
```

```{r Set_Directories}
# Ensure paths are set for code:
if (file.exists(outpath)) {
  cat("Output directory path works!")
} else {
  cat("Output directory does not exist - creating")
  dir.create(outpath)
}

# Number of participants/samples to process:
numsubs <- length(samples)
print(paste("Processing", numsubs, "samples", sep = " "))

# Documentation:
print(paste("This is where the project is:", normalizePath(projdir)))
print(paste("This is where the sample files are:", normalizePath(sample_dir)))
print(paste("This is where the data files will be saved:",
             normalizePath(outpath)))

# Set the file paths to DEG folder:
DEG_path <- paste0(outpath, "/DEG/")

# Confirm sample directory exists.
if (file.exists(DEG_path)) {
  cat("DEG directory path works!\n")
} else {
  cat("DEG directory does not exist - creating\n")
  dir.create(DEG_path)
}
```

```{r aggregate_single_cells}
change_path <- function (path) {
  # Confirm sample directory exists.
  if (file.exists(path)) {
    cat(path, " directory path works!\n")
  } else {
    cat(path, " directory does not exist - creating\n")
    dir.create(path)
  }
  return(path)
}

bulk_path <- change_path(paste0(outpath, "/DEG/pseudobulk_by_group/"))
plots_path <- change_path(paste0(bulk_path, "plots/"))

# Set random seed for reproducibility
set.seed(42)

# Extract raw counts and metadata to create SingleCellExperiment object
counts <- ss_data_norm@assays$RNA@counts
metadata <- ss_data_norm@meta.data

# Set the minimum number of nuclei that must express a gene for the gene to be
# included in DEG analysis
min_nuclei <- min(table(Idents(ss_data_norm)))

# Set up metadata as desired for aggregation and DE analysis
if (!is.null(combined)) {
  # Combine clusters if necessary
  metadata$cluster_id[!is.null(metadata[1])] <-
    as.vector(paste(combined, collapse = "-"))
} else {
  metadata$cluster_id <- factor(ss_data_norm@active.ident)
}
#rm(ss_data_norm)

# Create single cell experiment objects
sce <- SingleCellExperiment(assays = list(counts = counts), 
                            colData = metadata)
sce <- sce[rowSums(counts(sce) > 1) >= min_nuclei, ]
counts2 <- ss_data_norm@assays$SCT@scale.data
sce2 <- SingleCellExperiment(assays = list(counts = counts2), 
                             colData = metadata)
sce <- prepSCE(sce, kid = "cluster_id", gid = meta_vars[1], 
               sid = ID)
sce2 <- prepSCE(sce2, kid = "cluster_id", gid = meta_vars[1], 
               sid = ID)

# Store number and name of clusters and samples
nk <- length(kids <- levels(sce$cluster_id))
ns <- length(sids <- levels(sce$sample_id))
names(kids) <- kids
names(sids) <- sids

sce <- logNormCounts(sce)
sce2@assays@data@listData$logcounts <- sce2@assays@data@listData$counts

sce_pseudo <- aggregateData(sce, assay = "counts", fun = "sum",
                            by = c("cluster_id", "sample_id"))
sce2_pseudo <- aggregateData(sce2, assay = "counts", fun = "sum",
                            by = c("cluster_id", "sample_id"))

# Determine how to reorder the samples (rows) of the metadata to match the
# order of sample names in sids vector
reorder <- match(sids, sce$sample_id)

# Create the sample level metadata by combining the reordered metadata with
# the number of cells corresponding to each sample.
metadata_df <- data.frame(colData(sce)[reorder, ], row.names = NULL) %>%
               select("group_id", meta_vars[2])

ei <- metadata(sce)$experiment_info
ei$Sex <- metadata_df$Sex
design <- paste0("~ (ei$", str_c(meta_vars, collapse = " + ei$"), ")*(ei$",
                  str_c(meta_vars, collapse = " + ei$"), ")")
mm <- model.matrix(eval(str2expression(design)))
dimnames(mm) <- list(ei$sample_id, levels(ei$group_id), levels(ei$Sex))
contrast <- makeContrasts("AD-Ctrl", levels = mm)

sce_res <- pbDS(sce_pseudo, design = mm, contrast = contrast)
tbl <- sce_res$table[[1]]
tbl_fil <- lapply(tbl, function(u) {
  u <- dplyr::filter(u, p_adj.loc < 0.05, abs(logFC) > 1)
  dplyr::arrange(u, p_adj.loc)
})
n_de <- vapply(tbl_fil, nrow, numeric(1))
p_de <- format(n_de / nrow(sce) * 100, digits = 3)
data.frame("#DS" = n_de, "%DS" = p_de, check.names = FALSE)
```

``` {r DESeq2_DEG}
# Generate vector of cluster IDs
clusters <- unique(metadata$cluster_id)
clusters <- setdiff(clusters, remove)

# Generate gene lists for pathway analysis
pathways_kegg <- read.gmt("../data/c2.cp.kegg.v7.2.symbols.gmt")
pathways_react <- read.gmt("../data/c2.cp.reactome.v7.2.symbols.gmt")
pathways_wp <- read.gmt("../data/c2.cp.wikipathways.v7.2.symbols.gmt")
pathways_GO <- read.gmt("../data/c5.go.v7.2.symbols.gmt")
pathways_immune <- read.gmt("../data/c7.all.v7.2.symbols.gmt")

pathway_list <- c("pathways_GO", "pathways_immune", "pathways_kegg",
                  "pathways_react", "pathways_wp")

run_gsea <- function(pathway, results) {
  clusterProfiler::GSEA(results, TERM2GENE = pathway, seed = T) %>%
    arrange(p.adjust) %>% filter(p.adjust < 0.05)
}

save_gsea <- function(cluster, effect, gsea, path_name, res) {
  gsea_plot <- ggplot(gsea@result, aes(reorder(Description, NES), NES)) +
                      geom_col(aes(fill = NES > 0)) +
                      scale_fill_manual(values = c("#a6a6a6", "#5a5a5a")) +
                      coord_flip() +
                      theme_bw(base_size=22, base_line_size = 0,
                               base_rect_size = 0) +
                      theme(legend.position = "none") +
                      labs(x="Pathway", y="Normalized Enrichment Score",
                           title= paste0(path_name, "Enriched"))
  ggsave(filename = paste0(plots_path, cluster, "_", path_name,
                           "_chart_", effect, "_res", res, suffix, ".svg"),
         height = 14, width = 20, plot = gsea_plot)
  if (dim(gsea@result)[1] > 1) {
    eplot <- emapplot(gsea, color = "NES", showCategory = 100) +
               scale_color_continuous(low="blue", high="red")
    ggsave(filename = paste0(plots_path, cluster, "_", path_name, "_", method,
                             "_eplot_", effect, "_res", res, suffix, ".svg"),
           height = 14, width = 20, plot = eplot)
  }

  if (dim(gsea)[1] > 0) {
    # Write the significant pathways to a csv file.
    write.csv(as.data.frame(gsea@result),
              paste0(bulk_path, cluster, "_", path_name, "_enriched_", effect,
                     "_res", res, "_", suffix, ".csv"))
  }
}

heatmap_colors <- colorRampPalette(c("blue", "white", "red"))

# Perform DEG analysis between given metadata variables for each cluster
for (cluster in clusters) {
  # Print which cluster is being worked on
  print(paste("Determining DEGs for", cluster))
  
  bulk_path <- paste0(outpath, "/DEG/pseudobulk_by_group/")
  plots_path <- paste0(bulk_path, "plots/")

  # Subset the metadata
  cluster_metadata <- metadata[which(metadata$cluster_id == cluster), ]
  
  # Assign the rownames of the metadata to be the sample IDs
  rownames(cluster_metadata) <- cluster_metadata[[ID]]

  # Subset the counts to only the cluster
  sub_counts <- aggregate[[cluster]]
  cluster_counts <- as.data.frame(sub_counts[, which(colnames(sub_counts) %in%
                                                rownames(cluster_metadata))])

  # Check that all of the row names of the metadata are the same and in the same
  # order as the column names of the counts in order to use as input to DESeq2
  all(rownames(cluster_metadata) == colnames(cluster_counts))
  
  # Set the design of the DEG to test all variables given
  design <- paste("~ (", str_c(meta_vars, collapse = " + "), ")*(",
                  str_c(meta_vars, collapse = " + "), ")")
  
  for (meta_var in meta_vars) {
    # Print which groups are being plotted
    print(paste("Plotting heatmap and PCA for", meta_var))
    
    # Order the data by metadata group for visualization
    cluster_metadata <-
      cluster_metadata[order(as.vector(cluster_metadata[[meta_var]]),
                                       cluster_metadata[[ID]]),]
    
    # Create DESeq object for DEG analysis
    DEG_data <- DESeqDataSetFromMatrix(cluster_counts, 
                                       colData = cluster_metadata, 
                                       design = eval(str2expression(design)))
    
    # Transform counts for data visualization
    log_DEG_data <- rlog(DEG_data, blind=TRUE)
    
    # Extract the rlog matrix from the object and compute pairwise correlation
    # values
    log_matrix <- assay(log_DEG_data)
    log_matrix <- log_matrix[,match(cluster_metadata[[ID]], colnames(log_matrix))]
    log_cor <- cor(log_matrix)
    
    # Attempt to change color of heatmap annotation. Next, try deframe()
    # assign(Individual_Mutation_Status, c("#7e99b4", "blue"))
    # names(Individual_Mutation_Status) <- unique(cluster_metadata[[meta_var]])
    # mycolors <- list(Individual_Mutation_Status = Individual_Mutation_Status)
    # 
    # my_colors <- vector(mode = "list", length = 0)
    # my_colors[[meta_var]] <- c("#7e99b4", "blue")
    # 
    # assign(meta_var, NULL)
    # get_colors <- function(object) {
    #   group <- toString(object)
    #   object <- c("#7e99b4", "blue")
    #   names(object) <- unique(cluster_metadata[[group]])
    #   return(list(object = object))
    # }
    # 
    # my_colors <- get_colors(get(meta_var))
     
    # Plot PCA
    pca_data <- DESeq2::plotPCA(log_DEG_data, intgroup = meta_var,
                                returnData = TRUE)
    pca_plot <- ggplot(pca_data, aes_string("PC1", "PC2", color = meta_var)) +
                geom_point(size = 3) +
                coord_fixed() +
                labs(title = cluster) + 
                scale_color_manual(values = colors)
    print(pca_plot)
    ggsave(filename = paste0(plots_path, cluster, "_pseudo_pca_", meta_var,
                             "_res", chose_resolution, "_", suffix, ".png"),
           height = 7, width = 11, plot = pca_plot)
  
    # Plot heatmap
    heatmap <- pheatmap(log_cor, main = cluster,
                        color = heatmap_colors(200),
                        annotation = cluster_metadata[, meta_var, drop=F],
                        #annotation_colors = my_colors,
                        annotation_names_col = FALSE,
                        cluster_rows = FALSE, cluster_cols = FALSE)
    ggsave(filename = paste0(plots_path, cluster, "_pseudo_heatmap_", meta_var,
                             "_res", chose_resolution, "_", suffix, ".png"),
           height = 7, width = 11, plot = heatmap)
  }

  # Run DESeq2 differential expression analysis
  DEG_data <- DESeq2::DESeq(DEG_data)
  
  # Plot dispersion estimates
  plotDispEsts(DEG_data)
  
  # Get names of the effects tested
  names <- resultsNames(DEG_data)[-1]
  
  for (effect in names) {
    # Print which effect is being worked on
    print(paste("Determining DEGs for", effect))
    
    # Reset bulk directories
    bulk_path <- paste0(outpath, "/DEG/pseudobulk_by_group/")
    vol_path <- change_path(paste0(plots_path, "volcano_plots/"))
    
    # Create list of differential expression for all genes. This method
    # returns the Wald "stat" value for gsea analysis
    results <- results(DEG_data, name = effect, tidy = TRUE)
    
    # Plot a histogram of the p-values
    hist_plot <- ggplot(results, aes(x = padj)) + 
                 geom_histogram(color="black", fill="white") +
                 theme_bw(base_size=22, base_line_size = 0,
                          base_rect_size = 0)
    print(hist_plot)
    ggsave(filename = paste0(vol_path, "DEG_padj_hist_", cluster, "_",
                             effect, "_res.",
                             chose_resolution, suffix, ".svg"),
               height = 7, width = 7, plot = hist_plot)
    
    # Show genes with significant fold changes
    sig_markers <- filter(results,
                          padj < 0.05 & abs(log2FoldChange) > log2_threshold)
    print(sig_markers)
    
    # Create the volcano plot
    top_genes <- top_n(sig_markers, n = 10, wt = log2FoldChange)
    top_genes <- rbind(top_genes,
                       top_n(sig_markers, n = -10, wt = log2FoldChange))
    vol_plot <- ggplot(results) + 
                geom_jitter(aes(x = log2FoldChange, y = -log10(padj),
                               color = padj < 0.05 &
                                         abs(log2FoldChange) > log2_threshold),
                            width = .1, height = .1) +
                scale_color_manual(values = c("black", "blue")) +
                xlab("log2 fold change") + 
                ylab("-log10 adjusted p-value") +
                theme(legend.position = "none", 
                      plot.title = element_text(size = rel(1.5), hjust = 0.5), 
                      axis.title = element_text(size = rel(1.25)),
                      panel.grid.major = element_blank(),
                      panel.grid.minor = element_blank(),
                      panel.background = element_blank(),
                      axis.line = element_line(colour = "black"))
    if (nrow(top_genes > 1)) {
      vol_plot <- vol_plot +
                  geom_text_repel(aes(x = log2FoldChange,
                                      y = -log10(padj),
                                      label = ifelse(row %in% top_genes$row,
                                                     row,"")))
    }
    
    ggsave(filename = paste0(vol_path, "DEG_vol_plot_", cluster, "_",
                             effect, "_res.",
                             chose_resolution, suffix, ".svg"),
               height = 7, width = 7, plot = vol_plot)
    
    if (dim(sig_markers)[1] > 0) {
    
      gene_list <- sig_markers$row
      
      DEG_matrix <- as.matrix(sub_counts)
      DEG_matrix <- subset(DEG_matrix, row.names(DEG_matrix) %in% gene_list)
      DEG_matrix <-
        rbind(as.character(metadata[[meta_vars[1]]][1:dim(cluster_metadata)[1]]),
              DEG_matrix)
      rownames(DEG_matrix)[1] <- meta_vars[1]
      DEG_matrix <- t(DEG_matrix)
      DEG_matrix <- as.data.frame(DEG_matrix)
      DEG_matrix[[meta_vars[1]]] <- as.factor(DEG_matrix[[meta_vars[1]]])
      DEG_matrix[[meta_vars[1]]] <- relevel(DEG_matrix[[meta_vars[1]]],
                                            ref = ref[1])
  
      vln_path <- change_path(paste0(plots_path, "violin_plots/"))
      vln_plots <- NULL
      for (gene in 1:length(gene_list)) {
        DEG_matrix[[gene_list[[gene]]]] <-
          as.integer(DEG_matrix[[gene_list[[gene]]]])
        vln_plots[[gene]] <- ggplot(DEG_matrix,
                                    aes_(x = as.name(meta_vars[1]),
                                        y = as.name(gene_list[[gene]]),
                                        fill = as.name(meta_vars[1]))) +
                             #ylim(-1, 1.5) +
                             geom_violin(trim = F) +
                             scale_fill_manual(values = colors)
        ggsave(filename = paste0(vln_path, "DEG_vln_plot_", cluster, "_",
                                 effect, "_", gene_list[[gene]], "_res.",
                                 chose_resolution, suffix, ".svg"),
               height = 7, width = 7, plot = vln_plots[[gene]])
      }
      plot4 <- wrap_plots(vln_plots) +
               plot_annotation(title = effect)
      ggsave(filename = paste0(vln_path, "DEG_vln_plot_", cluster, "_", effect,
                               "_res.", chose_resolution, suffix, ".svg"),
             height = 7, width = 14, plot = plot4)
    
      # Print which effect is being printed
      print(paste("Saving DEGs for", effect))
      
      # Write the significant DEGs to a csv file.
      write.csv(filter(results,
                       padj < 0.05 & abs(log2FoldChange) > log2_threshold),
                paste0(bulk_path, cluster, "_pseudo_DEGs_", effect,
                       "_res", chose_resolution, suffix, ".csv"))
    }
    # Change row names to a column
    results <- setDT(results, keep.rownames = TRUE)
    top10_genes <- top_n(results, n = 10, wt = log2FoldChange)[,2]
    bottom10_genes <- top_n(results, n = -10, wt = log2FoldChange)[,2]
    DEG_matrix <- as.matrix(sub_counts)
    DEG_matrix <- subset(DEG_matrix, row.names(DEG_matrix) %in% top10_genes$row |
                           row.names(DEG_matrix) %in% bottom10_genes$row)
    DEG_matrix <- DEG_matrix[,as.character(cluster_metadata[[ID]])]
    heatmap <- pheatmap(DEG_matrix, scale = "row", color = heatmap_colors(200),
                        annotation_names_col = FALSE, cluster_rows = FALSE,
                        cluster_cols = FALSE)
    ggsave(filename = paste0(plots_path, cluster, "_pseudo_DEG_heatmap_", meta_var,
                             "_res", chose_resolution, "_", suffix, ".svg"),
           height = 7, width = 11, plot = heatmap)
    
    if (identical(method, "lfc") & dim(filter(results, padj < 0.05))[1] > 0) {
      # Print which GSEAs are being run
      print(paste("Running lfc GSEAs for", effect, "in", cluster))
      
      # Run GSEA using shrunken log2 fold change
      # Change output folders
      bulk_path <- change_path(paste0(outpath,
                                      "/DEG/pseudobulk_by_group/lfc_GSEA/"))
      plots_path <- change_path(paste0(bulk_path, "plots/"))
      
      # Returns the differential expression of all genes, shrinking the fold
      # change using apeglm. This is the recommended method from DESeq2 authors
      results <- as.data.frame(lfcShrink(DEG_data, coef = effect,
                                       type = "apeglm"))
        
      # Keep only gene symbol and stat value for pathway analysis
      results_lfc <- results %>%
        dplyr::select(rn, log2FoldChange) %>%
        na.omit() %>%
        distinct() %>%
        group_by(rn) %>%
        deframe() %>%
        sort(decreasing = T)
      
      ties <- as.data.frame(table(results_lfc))
      ties <- ties[ties$Freq > 2,]
      print(paste("Removing", sum(ties$Freq),
                  "genes with log2 fold change equal to more than one other gene"))
      results_lfc <- results_lfc[!results_lfc %in% ties$results_lfc]

  
      # Run the sgea algorithm for each pathway
      for (pathway in pathway_list) {
        gsea_results <- run_gsea(pathway, results_lfc)
        if (dim(gsea_results@result)[1] > 0) {
          save_gsea(cluster, effect, gsea_results, pathway,
                   chose_resolution)
        }
      }
      
      # Remove unnecessary variables
      rm(results_lfc)
      
    } else if (identical(method, "-log10p")) {
      # Print which GSEAs are being run
      print(paste("Running -log10p GSEAs for", effect, "in", cluster))
      
      # Run GSEA using -log10(adj. p-value)
      # Change output folders
      bulk_path <- change_path(paste0(outpath,
                                      "/DEG/pseudobulk_by_group/log10p_GSEA/"))
      plots_path <- change_path(paste0(bulk_path, "plots/"))
      
      # Returns the differential expression of all genes, shrinking the fold
      # change using apeglm. This is the recommended method from DESeq2 authors
      results <- as.data.frame(lfcShrink(DEG_data, coef = effect,
                                       type = "apeglm"))
      
      # Keep only gene symbol and stat value for pathway analysis
      results_pval <- results %>%
        dplyr::select(rn, pvalue) %>%
        mutate(log10p = log10(pvalue) * -1) %>%
        mutate(padj = NULL) %>%
        na.omit() %>%
        distinct() %>%
        group_by(rn) %>%
        deframe()
  
      # Run the fsgea algorithm for each pathway
      for (pathway in pathway_list) {
        gsea_results <- run_gsea(pathway, results_pval)
        if (dim(gsea_results@result)[1] > 0) {
          save_gsea(cluster, effect, gsea_results, pathway,
                   chose_resolution)
          if (dim(gsea_results@result)[1] > 20) {
            gsea_results %>%
            group_by(NES) %>%
            filter(!between(dense_rank(NES), 11, n() - 10))
          }
        }
      }
      
      # Remove unnecessary variables
      rm(results_pval)
      
    } else if (identical(method, "wald")) {
      # Print which GSEAs are being run
      print(paste("Running Wald GSEAs for", effect, "in", cluster))
      
      # Run GSEA using Wald statistic
      # Change output folders
      bulk_path <- change_path(paste0(outpath,
                                      "/DEG/pseudobulk_by_group/Wald/"))
      plots_path <- change_path(paste0(bulk_path, "plots/"))
      
      # Keep only gene symbol and stat value for pathway analysis
      results <- results %>%
        dplyr::select(row, stat) %>%
        na.omit() %>%
        distinct() %>%
        group_by(row) %>%
        deframe() %>%
        sort(decreasing = T)
  
      # Run the gsea algorithm for each pathway and save plots
      for (pathway in pathway_list) {
        gsea_results <- run_gsea(get(pathway), results)
        if (dim(gsea_results@result)[1] > 0) {
          save_gsea(cluster, effect, gsea_results, pathway, chose_resolution)
          if (dim(gsea_results@result)[1] > 20) {
            gsea_results@result <- gsea_results@result %>%
            filter(!between(dense_rank(NES), 11, n() - 10))
            gsea_results@result$Description <- sub(".*?_", "",
                                                   gsea_results@result$Description)
            save_gsea(paste0(cluster, "_top10"), effect, gsea_results, pathway,
                      chose_resolution)
          }
        }
      }
    }
  }
}
```

```{r save_data}
# Remove extraneous variables from the workspace
rm(gene, start_data, sub_counts, cluster_counts, cluster_metadata, params,
   DEG_data, DEG_matrix, kids, sids, splitf, res_name, reorder, names, n_cells,
   log2_threshold, method, meta_vars, meta_var, meta_factors, group, effect,
   design, de_samples, de_cluster_ids, colors, cluster, clusters, log_DEG_data,
   change_resolution, change_output_path, vln_plots, samples_list, gg_df, groups,
   results, gene_list, top10genes, bottom10genes, results, ties, DEG_heatmap,
   pca_plot, pca_data, heatmap, plot4, log_cor, log_matrix, clust_sample_table,
   gsea_results, sig_markers, top10_genes, bottom10_genes, hist_plot)

# Save the Seurat object so that we can load it again later
print("Saving the workspace...")
if (is.null(combined)) {
  save.image(file = paste0(rfiles_path, "pseudobulk_ws", suffix,
                           ".rdata"), compress = TRUE)
} else {
  save.image(file = paste0(rfiles_path, paste(combined, collapse = "-"),
                           "_pseudobulk_ws", suffix, ".rdata"), compress = TRUE)
}
```
