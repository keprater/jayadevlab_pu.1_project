---
title: "snRNAseq_clusters_v1"
author: "Katie Prater and Kevin Green"
date: "6/24/2020"
output: 
  html_document:
    df_print: paged
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(Seurat)
library(Matrix)
library(ggplot2)
library(stringr)
library(dplyr)
library(filesstrings)
```
#Jayadev Lab snRNAseq Pipeline

##Removal of unwanted batch/sample effects for cleanup of data

### R Markdown note:
This is an R Markdown document. When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document.

##First ensure you have the variables and directories set up as needed for the project.  ***You DO need to edit this code chunk! ***
```{r Setup}
#Define your project folder:
#projdir <- "path_to_my_project_folder_name"
projdir <- "/home/rstudio/hyak/projects/single_cell/brain/pu1_only/2020-07-07_15_samples/"

#Previous data file name: (give the name for the appopriate RDS/Rdata file)
start_data <- "QCd_normalized_pu1_only_ws.rdata"

#Define the number of genes you want after variable gene detection:
nfeatures <- 5000

#Subset samples (by batch or patient group)?
sample_sub <- TRUE

#Give variable name to subset on:
var_subset <- "Dx"

#Use reference?
use_reference <- FALSE

#Set a list of reference samples to use for integration
#Set to NULL if no reference sample is used
reference_samples <- c(1, 8, 2, 3)


#__________________**DO NOT EDIT BELOW THIS LINE**___________________________
```

## Load in the data you specified:
```{r Load_Data}
#Document your code:
print("This is when this code was started:")
print(Sys.time())

#Load the thresholded Seurat object saved before
data_loc<-file.path(projdir, "code", start_data, fsep = "/")
print(paste('Loading data', start_data, sep = " "))
load(start_data)
```

```{r Set_Directories}
#Ensure paths are set for code:
outpath <- file.path(projdir, outdir, "umaps", fsep = "/")
if (file.exists(outpath))
    {cat("Output directory path works!")} else 
    {cat("Output directory does not exist - creating")
    dir.create(outpath)}

#Number of participants/samples to process:
numsubs <- length(samples)
print(paste("Processing", numsubs, "samples", sep = " "))

#Documentation:
print("This is where the project is:")
print(projdir)
print("This is where the sample files are:")
print(sample_dir)
print("This is where the data files will be saved:")
print(outpath)

```

## We split the Seurat object into individual samples to find the variable genes in each sample, generate a weighted list of those genes for all samples, and then determine integration anchors based on a reference if defined above, or compared to other samples.
```{r Var_genes_&_anchors, warning=FALSE}

#Subset the samples if needed and run integration on the subsets, else run without subsetting.
if(sample_sub){#If true, subset the samples.
  
  print(paste("Subsetting dataset with", var_subset, sep = " "))
  
  ss_data_norm <- SplitObject(ss_data_norm, split.by = var_subset)
  
  print(paste("Split Seurat object now has", length(unique(names(ss_data_norm)))
, "groups.", sep = " "))

  #Run normalization for each subset of the data.
  for (i in names(ss_data_norm)) {
    ss_data_norm[[i]] <- SCTransform(ss_data_norm[[i]], 
                                     variable.features.n = nfeatures,
                                     #do.scale = FALSE,
                                     #do.center = FALSE,
                                     conserve.memory = TRUE,
                                     return.only.var.genes = TRUE,
                                     #vars.to.regress = "percent.mito",
                                     verbose = FALSE)
  }
  
    #Save rds of the anchorset 
  saveRDS(ss_data_norm, file = paste0("QCd_data_subset_", var_subset ,"_normed_wscale", suffix, ".rds"))
  
   #Find the integration features similar across all samples for the top nFeatures of genes.
  Ifeatures <- SelectIntegrationFeatures(ss_data_norm, nfeatures = nfeatures,)
  
  #Ensure we're using the normalized data to integrate.
  ss_data_norm <- PrepSCTIntegration(ss_data_norm, anchor.features = Ifeatures)
  
  if(use_reference){ #If use_reference = True, run this for subgroup_2
    
    # Find integration anchors for individual samples to correct for sample batch effects using the Integration features identified above and references. 
#*Note that this step takes many hours (7 for 15 samples)
print(paste("Finding integration anchors using", names(ss_data_norm2[reference_samples2]), "as reference samples.", sep = " "))
ss_data_norm2 <-
  FindIntegrationAnchors(ss_data_norm2,
    reference = reference_samples2,
    normalization.method = "SCT",
    anchor.features = Ifeatures,
    reduction = "cca",
    dims = 1:30,
  )
  }else{ #If use_reference is not true, run this
    
    # Find integration anchors for individual samples to correct for sample batch effects using the Integration features identified above using no references. 
#*Note that this step takes many hours (7 for 15 samples)
print("Finding integration anchors using no reference samples.")
ss_data_norm <-
  FindIntegrationAnchors(ss_data_norm,
    normalization.method = "SCT",
    reference = NULL,
    anchor.features = Ifeatures,
    reduction = "cca",
    dims = 1:30,
  )
  }
  
  #Save rds of the anchorset 
  saveRDS(ss_data_norm, file = paste0("QCd_data_subset_", var_subset ,"_anchored_wscale", suffix, ".rds"))
  
  #Integrate the datasets from each sample together.
ss_data_norm <- IntegrateData(ss_data_norm,
                              normalization.method = "SCT",
                              dims = 1:30)
  


}else{ #If the data is not to be subsetted, run this:

  #Split the combined Seurat object into individual samples to be integrated
ss_data_norm <- SplitObject(
    ss_data_norm,
    split.by = "orig.ident")
print(paste("Split Seurat object now has", length(unique(names(ss_data_norm)))
, "individual samples.", sep = " "))

#Find the variable genes for each individual samples
ss_data_norm <- lapply(X = ss_data_norm, FUN = function(x) {
    x <- FindVariableFeatures(x, selection.method = "vst", nfeatures = nfeatures, verbose = FALSE)
})
  
#Find the integration features similar across all samples for the top nFeatures of genes.
Ifeatures <- SelectIntegrationFeatures(ss_data_norm, nfeatures = nfeatures,)


# Find integration anchors for individual samples to correct for sample batch effects using the Integration features identified above. 
#*Note that this step takes many hours (7 for 15 samples)
print(paste("Finding integration anchors using", names(ss_data_norm[reference_samples]), "as reference samples.", sep = " "))
ss_data_norm <-
  FindIntegrationAnchors(ss_data_norm,
    reference = reference_samples,
    anchor.features = Ifeatures,
    reduction = "cca",
    dims = 1:30,
  )

#Save rds of the anchorset 
saveRDS(ss_data_norm, file = paste0("anchorset_data",suffix, ".rds"))

#Integrate the datasets from each sample together.
ss_data_norm <- IntegrateData(ss_data_norm,
                              dims = 1:30)
}


```

## Save the data files.
```{r Save_Files}

#Save workspace image if needed to revisit
save.image(file = paste0("QCd_norm_anchored_wscale", var_subset, "_ws", suffix, ".rdata"), compress = TRUE)

```

## Make a couple of quick umap plots to confirm that the batch correction worked well.
```{r UMAP_plot}
#Set default assay
DefaultAssay(ss_data_norm) <- "integrated"

#Run PCA and UMAP to get the data
ss_data_norm <- RunPCA(object = ss_data_norm, verbose = FALSE)
ss_data_norm <- RunUMAP(object = ss_data_norm, dims = 1:30)


#Make a standard UMAP plot of the clusters
plot1 <- DimPlot(object = ss_data_norm,
                     reduction = "umap",
                     group.by = var_subset,
                     split.by = var_subset,
                     pt.size = 2,
                     label = FALSE,
                     label.size = 10)
    #plot1[[1]]$layers[[1]]$aes_params$alpha = .2
    png(paste0(outpath, "/", proj, "_",
                "integrated_clusters_wscale", "_",
                "postQC", suffix, ".png", sep = ""), 1000, 800)
    print(plot1)
    dev.off()
    
#Save the current identities as cluster metadata
#ss_data_norm$clusternum <- Idents(ss_data_norm)

# Next, switch the identity class of all cells to reflect sample ID
Idents(ss_data_norm) <- "orig.ident"

#Make a standard UMAP plot of the clusters
plot2 <- DimPlot(object = ss_data_norm,
                     reduction = "umap",
                     #group.by = resolutions[[resolution]],
                     pt.size = 2,
                     label = FALSE,
                     label.size = 10)
    plot2[[1]]$layers[[1]]$aes_params$alpha = .2
    png(paste0(outpath, "/", proj, "_",
                "integrated_samples_wscale", "_",
                "postQC", suffix, ".png", sep = ""), 800, 800)
    print(plot2)
    dev.off()
    
#Make a standard UMAP plot of the clusters
plot3 <- DimPlot(object = ss_data_norm,
                     reduction = "umap",
                     split.by = "orig.ident",
                     pt.size = 2,
                     label = FALSE,
                     label.size = 10,
                     ncol = 5)
    png(paste0(outpath, "/", proj, "_",
                "integrated_samples_split_wscale", "_",
                "postQC", suffix, ".png", sep = ""), 1200, 1200)
    print(plot3)
    dev.off()

```



